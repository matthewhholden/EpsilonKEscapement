RunAnalyis = function(r, k, phi, std, escFunctions, optFunctions,
                      n.dat, n.sim, n.mod, n.turn,
                      type.fit, type.dat){
  #calculate the yield resulting from fitting models from the list of models escFunctions
  #type.fit = 'log' for fitting log(y) ~ log(x) - mu + eps, other strings yield regular 
  #nonlinear least squares minimization
  #r is growth rate, k = carrying capacity, phi = density dependence modifier for pella Tomlinson model
  #n.dat = length of data used to fit the models
  #n.sim = number of simulations where models are fit
  #type.dat = 'sim' if the data is generated from a simulated fishery, 
  # 'rand' if generated by entering randomly uniformly distributed biomass,
  # x ~ U( 0, (1+std)*k ), 
  # then letting y ~ z f(x)
  
  ####
  #Generate escapement data, (EscDat 4D array) 
  ####
  #dim1 = model used to generate data
  #dim2 = the simulation number
  #dim3 = the data point index
  #dim4 = 1 for input biomass (x), 2 for output biomass (y)
  
  escDat = array( NA, dim = c( n.mod, n.sim, n.dat, 2 ) ) #initialize
  
  # Sim option for type.dat means the x values for the fit are genarated by simulating 
  # the population from 20% of carrying capacity for 50 generations
  # 'rand' option generates the x data randomly and the y data as the out put from 
  # the model
  
    if(type.dat == 'sim') dataGenFunc = GenerateDataS
    else if(type.dat == 'rand') dataGenFunc = GenerateDataR
    
    for(i in 1:n.mod){
      
      escDat[i,,,] = dataGenFunc( escFunctions[[i]], std=std, parms=pars, 
                                    n = n.dat, n.sim = n.sim )
    }

  
  ###########
  ## Fit data to models, 
  ###########
    #Fitted parameter values are stored in 'fPars'
    #dim1 = model used to generate data
    #dim2 = fitted model 
    #dim3 = simulation number
    #dim4 = parameter values
 
    fPars = FitData(funcs = escFunctions, dat = escDat, p0 = pars, 
                    type.fit = type.fit, std=std)
  
  
  #######  
  ## calculate Optimal Escapement
  #######
    optEsc = array(NA, dim = c(n.mod, n.mod, n.sim))
    optEscT = c(k/r*(sqrt((1+r)) -1), 
                k/(1+r),
                (1/(phi+1))^(1/phi) * k  ) #optimal escapement in true model
    
    for(mf in 1:n.mod){
      optEsc[,mf,] = optFunctions[[mf]](fPars[,mf,,])
    }
  
  #####
  ## calculate Yield
  #####
    #Use optimal escapement rule in a n turn game (with all fish harvested at time n+1)  
    #mt is the true model index, mf is the fitted model index, i is the simulation #
  
    #initialize variables
      yield = array(NA, dim = c(n.mod, n.mod, n.sim))
      yieldT = array(NA, dim = c(n.mod, n.sim));
      yT = array(NA, dim = c(n.mod, n.sim, n.turn));
      y = array(NA, dim = c(n.mod, n.mod, n.sim, n.turn));
      xT = array(NA, dim = c(n.mod, n.sim, n.turn+1));
      x = array(NA, dim = c(n.mod, n.mod, n.sim, n.turn+1));
  
      for(i in 1:n.sim){
        
        z = GenerateZ(std, n.turn)
        
        for(mt in 1:n.mod){
          #yield generated from opt escapement of true model with parameters known
          outPutT = SimulateStrategy(func = escFunctions[[mt]], 
                                    n = n.turn, optEscT[mt], 
                                    std = std, pars = pars, z=z)
          yieldT[mt, i] = outPutT[[1]]
          yT[mt, i, ] = outPutT[[2]]
          xT[mt, i, ] = outPutT[[3]]
          
          for(mf in 1:n.mod){
            #yield generated from opt escapement of each fitted model 
            outPut = SimulateStrategy(func = escFunctions[[mt]], 
                                      n = n.turn, optEsc[mt,mf,i], 
                                      std = std, pars = pars, z=z)
            yield[mt,mf,i] = outPut[[1]]
            y[mt,mf,i, ] = outPut[[2]]
            x[mt,mf,i, ] = outPut[[3]]
          }
        }
      }
  
  return(  list(yield, optEsc, fPars, yieldT, optEscT, yT, y, xT, x)   ) 
}
